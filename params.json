{"name":"pta2smt","tagline":"Parametric Timed Automata SMT checker","body":"Satisfiability Modulo Theories Parametric Timed Automata Tool\r\n=============================================================\r\n\r\nThis is a prototype tool for synthesis of parameters under which some given state of a system\r\ndescribed using Parametric Timed Automata is reachable. It's a companion to paper\r\nhttp://www.ceur-ws.org/Vol-851/paper6.pdf.\r\n\r\nConfiguration / prerequisites\r\n---------------------------------------------------------------------------\r\n\r\nApart from usual dependencies the tool needs to have an access to smtlib2\r\ncompliant SMT checker. (It has been tested with CVC3 only.)\r\nThe command to start SMT checker needs to be included in the experiment's \r\nplan file. \r\n\r\nBasic usage\r\n---------------------------------------------------------------------------\r\n\r\nBelow you can find an example of 2-process Mutex consisting of two \r\nprocesses (Proc0, Proc1) and synchronising shared variable model (Sync).\r\nTo understand the model you need to consult the cited paper: one look\r\nat Figure 1 should explain everything. The only nonintuitive thing is\r\nperhaps that nonlabeled states need to be marked with *labelling: false*.\r\n(The parser was written in a hurry.)\r\n\r\n\r\n```\r\nnetwork Mutex {\r\n\r\nautomaton Proc0 {\r\nlocations:\r\ninitial location(idle0)\r\n        invariant: true, labelling: false;\r\n\r\n        location(trying0)\r\n        invariant: true, labelling: false;\r\n\r\n        location(waiting0)\r\n        invariant: true, labelling: false;\r\n\r\n        location(critical0)\r\n        invariant: true, labelling: bad0;\r\ntransitions:\r\n            (idle0, trying0)\r\n            action: start0,\r\n            guard: true,\r\n            reset: x0 = 0;\r\n\r\n            (trying0, waiting0)\r\n            action: setx0,\r\n            guard: x0 < Delta,\r\n            reset: x0 = 0;\r\n\r\n            (waiting0, critical0)\r\n            action: enter0,\r\n            guard: x0 > delta,\r\n            reset: true;\r\n\r\n            (critical0, idle0)\r\n            action: setx00,\r\n            guard: true,\r\n            reset: true;\r\n};\r\n\r\nautomaton Proc1 {\r\nlocations:\r\ninitial location(idle1)\r\n        invariant: true, labelling: false;\r\n\r\n        location(trying1)\r\n        invariant: true, labelling: false;\r\n\r\n        location(waiting1)\r\n        invariant: true, labelling: false;\r\n\r\n        location(critical1)\r\n        invariant: true, labelling: bad1;\r\ntransitions:\r\n            (idle1, trying1)\r\n            action: start1,\r\n            guard: true,\r\n            reset: x1 = 0;\r\n\r\n            (trying1, waiting1)\r\n            action: setx1,\r\n            guard: x1 < Delta,\r\n            reset: x1 = 0;\r\n\r\n            (waiting1, critical1)\r\n            action: enter1,\r\n            guard: x1 > delta,\r\n            reset: true;\r\n\r\n            (critical1, idle1)\r\n            action: setx01,\r\n            guard: true,\r\n            reset: true;\r\n};\r\n\r\nautomaton Sync {\r\nlocations:\r\ninitial location(zero)\r\n        invariant: true, labelling: false;\r\n\r\n        location(process0)\r\n        invariant: true, labelling: false;\r\n\r\n        location(process1)\r\n        invariant: true, labelling: false;\r\ntransitions:\r\n            (zero, zero)\r\n            action: start0,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (zero, zero)\r\n            action: start1,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (zero, process0)\r\n            action: setx0,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (zero, process1)\r\n            action: setx1,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process0, zero)\r\n            action: setx00,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process1, zero)\r\n            action: setx01,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process0, process0 )\r\n            action: enter0,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process1, process1 )\r\n            action: enter1,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process0, process0 )\r\n            action: setx0,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process0, process1)\r\n            action: setx1,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process1, process0)\r\n            action: setx0,\r\n            guard: true,\r\n            reset: true;\r\n\r\n            (process1, process1)\r\n            action: setx1,\r\n            guard: true,\r\n            reset: true;\r\n};\r\n};\r\nproperty: bad0 and bad1;\r\n```\r\n\r\nThe model source should be paired with an experiment plan file. For example the\r\nbelow plan first gives the command invoking the cvc3 SMT checker \r\n( *cvc3 -lang smtlib2* ), then follows with the definition of the logic \r\n( *QF_LRA* ), indicates the lower parameters in the model ( *delta* )\r\nand says that the experiment should start with unwinding of the model up to 2\r\nand synthesis of not more than 10 parameters and then move to 4 and 5 parameters,\r\netc.\r\n\r\n```\r\ncvc3 -lang smtlib2\r\nQF_LRA\r\ndelta\r\n2 10\r\n4 5\r\n5 2\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}